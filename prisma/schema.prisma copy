// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  ///////////////////////////////////////////////////////////////////////////
  //
  // Prisma has recently updated its default configuration. 
  // The Prisma Client is no longer generated inside node_modules/.prisma/client 
  // by default. Instead, users are required to explicitly define an output path.
  // Prisma now strongly recommends specifying an output location, and common 
  // choices include app/generated, src/generated, or even the project root.
  //
  //  https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-location-of-prisma-client
  //  We strongly recommend you define a custom output path. In Prisma ORM version 6.6.0, not defining an output path will result 
  //  in a warning. In Prisma ORM 7, the field will be required.
  //
  // ⚠️ Exclude the generated directory from version control in .gitignore: /src/generated/prisma
  // https://www.prisma.io/docs/orm/prisma-schema/overview/generators#3-exclude-the-generated-directory-from-version-control
  //
  ///////////////////////////////////////////////////////////////////////////
  output   = "../src/generated/prisma"
  // https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters
  //  previewFeatures = ["driverAdapters"]

  // Update your schema.prisma to explicitly include Vercel's platform: "rhel-openssl-3.0.x"
  // This normally isn't an issue, until you try to deploy manually from GitHub Actions.
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

model User {
  ///////////////////////////////////////////////////////////////////////////
  //
  // In Brad's mini-project, Full App Build ( https://www.youtube.com/watch?v=I6DCo5RwHBE&t=17s )
  // he uses: String @id @default(uuid())
  // This uses Prisma's built-in uuid() function to generate UUIDs
  // The UUID is generated by Prisma client at query time
  // Conversely, gen_random_uuid() is a function native to PostgreSQL.
  // In the latter case, the UUID is generated by the database itself during insertion.
  // The @db.Uuid directive tells Prisma to use PostgreSQL's native UUID type instead of VARCHAR.
  // The database engine handles the UUID generation.
  // The second approach (dbgenerated + @db.Uuid) is generally considered better for PostgreSQL for several reasons:
  //
  //   1. Type safety: Using the native UUID type in PostgreSQL (@db.Uuid) is more type-safe 
  //      and storage-efficient than storing UUIDs as strings.
  //
  //   2. Performance: Database-generated UUIDs can be more efficient since the database handles generation 
  //      without additional network round-trips.
  //  
  //   3. Consistency: Using PostgreSQL's native UUID functions ensures the values are 
  //      generated consistently by the database engine.
  //
  //   4. Indexing: PostgreSQL can more efficiently index its native UUID type compared to string representations.
  //
  //   5. Constraints: The database will enforce proper UUID formatting at the database level.
  //
  // Note: cuid() may be a more collision-resistant option than uuid().
  // There also appears to be a ulid() that I've seen used in some official Prisma tutorials.
  //
  // Prisma docs show example of using gen_random_uuid() here:
  //
  //   https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#native-database-functions
  // 
  // https://www.prisma.io/docs/orm/prisma-schema/data-model/models#using-functions
  // Support for autoincrement(), now(), and dbgenerated(...) differ between databases.
  //
  ///////////////////////////////////////////////////////////////////////////

  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  firstName String
  lastName  String
  email     String   @unique
  password  String
  role      Role     @default(USER)
  // Working with JSON Fields in Prisma ORM: https://www.youtube.com/watch?v=gcpcxMxJ1AQ
  // At the 5 minute mark he shows how to use the generic path property to search for a key
  // with a specific value.
  // In Postgres, Json maps to jsonb by default, but why not just  use that?
  address   Json?    @db.Json // @db.Json may be redundant when using Postgres.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  posts     Post[]

  @@map("users")
}

model Post {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title     String   @unique
  body      String
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}
